% ==================================================
% Fichier : debug.hxv
% Dernière mise-à-jour : 31 août 2008
% ==================================================
\index{debugging}

% Different kinds of errors can occur
% in a program, and it is useful to distinguish among them
% in order to track them down more quickly:

Des erreurs de types diff\'erentes peuvent appara\^{\i}tre dans un programme.
Pour les d\'epister il est utile de les distinguer:

\begin{itemize}

% \item Syntax errors are produced by Python when it is translating the
%   source code into byte code.  They usually indicate that there is
%   something wrong with the syntax of the program.  Example: Omitting
%   the colon at the end of a {\tt def} statement yields the somewhat
%   redundant message {\tt SyntaxError: invalid syntax}.

\item Un erreur de syntaxe est produit par {\sc Python} quand le code source
est traduit au code machine.  Des tels erreurs indique normalement qu'il y a quelque chose
avec le syntaxe de votre programme.  Exemple: L'omision d'un point-virgule (;) \`a la fin
d'une d\'eclaration {\tt def} a comme r\'esultat le m\'essage un peu redondant
{\tt SyntaxError: invalid syntax}.

% \item Runtime errors are produced by the interpreter if something goes
%   wrong while the program is running.  Most runtime error messages
%   include information about where the error occurred and what
%   functions were executing.  Example: An infinite recursion eventually
%   causes the runtime error ``maximum recursion depth exceeded.''

\item  Un erreur d'exc\'ecution est produit par le syst\`eme au moment
d'ex\'ecution du programme s'il y a quelque chose qui se passe pendant
que le programme se tourne.  La plus part des erreurs d'exc\'ecution
comprend des informations sur la location de l'erreur qui vient de
se passer et quelles fonctions \'etaient utilis\'ees \`a ce moment.
Exemple: Une recursion infinie produira apr\`es un certain temps
l'erreur d'exc\'ecution {\tt maximum recursion depth exceeded}.

% \item Semantic errors are problems with a program that runs without
%   producing error messages but doesn't do the right thing.  Example:
%   An expression may not be evaluated in the order you expect, yielding
%   an incorrect result.

\item  Un erreur semantique est un probl\`eme avec un programme
qui compile et qui tourne mais ne fait pas ce qu'on veut.
Exemple: Une expression qui n'est pas \'evalu\'ee dans l'ordre
attendue, donnant ainsi un r\'esultat non attendu.

\end{itemize}

\index{syntax error}
\index{runtime error}
\index{semantic error}
\index{error!compile-time}
\index{error!syntax}
\index{error!runtime}
\index{error!semantic}
\index{exception}

% The first step in debugging is to figure out which kind of
% error you are dealing with.  Although the following sections are
% organized by error type, some techniques are
% applicable in more than one situation.

La premi\`ere \'etape en faisant le d\'eboguage est d'identifier le type
d'erreur avec le quel vous avez \`a faire.  Les sections suivantes sont
organis\'ees par type d'erreur, mais certaines des techniques sont applicables
dans plus qu'un seul contexte.

% --------------------------------------
% \section{Syntax errors}
\section{Erreur de syntaxe}
% -------------------------------

\index{error message}

% Syntax errors are usually easy to fix once you figure out what they
% are.  Unfortunately, the error messages are often not helpful.
% The most common messages are {\tt SyntaxError: invalid syntax} and
% {\tt SyntaxError: invalid token}, neither of which is very informative.

Les erreurs de syntaxe sont normalement facile \`a \'eliminer d\`es que vous
les avez identifi\'es.  Malheureusement souvent les messages d'erreur ne sont pas
souvent tr\`es utiles.  Les messages les plus courants sont {\tt SyntaxError: invalid syntax}
et {\tt SyntaxError: invalid token}.  Ni l'un ni l'autre n'est tr\`es parlant.

% On the other hand, the message does tell you where in the program the
% problem occurred.  Actually, it tells you where Python
% noticed a problem, which is not necessarily where the error
% is.  Sometimes the error is prior to the location of the error
% message, often on the preceding line.

Par contre, le message vous dit normalement o\`u s'est pass\'e l'erreur.  Plus
exactement il vous dit o\`u {\sc Python} a remarqu\'e le probl\`eme, ce qui
n'est pas forc\'ement o\`u se trouve l'erreur.  Par fois l'erreur se trouve
\`a un endroit du code ant\'erieur du memssage d'erreur, souvant dans la ligne
juste avant.

\index{incremental development}
\index{development plan!incremental}

% If you are building the program incrementally, you should have
% a good idea about where the error is.  It will be in the last
% line you added.

Si vous construisez votre programme peu \`a peu en v\'erifiant \`a chaque
\'etape que \c{c}a marche, vous devez avoir une bonne id\'ee d'o\`u se
trouve l'erreur.  Il sera dans la derni\`ere ligne que vous venez d'ajouter.

% If you are copying code from a book, start by comparing
% your code to the book's code very carefully.  Check every character.
% At the same time, remember that the book might be wrong, so
% if you see something that looks like a syntax error, it might be.

Si vous copiez un code d'un bouquin, commencez par une comparaison ligne par ligne
entre votre code et ce du bouquin.  V\'erfiez chaque charact\`ere.  Au m\^eme
temps, rappelez-vous que le code du bouquin peut aussi comprendre des erreurs.
Donc si vous voyez dans le code du bouquin quelque chose qui vous semble un erreur
de syntaxe, il est bien possible qu'il s'ag\^{\i}t r\'eelement d'un erreur de syntaxe.

% Here are some ways to avoid the most common syntax errors:

Voici des strat\'egies pour \'eviter les erreurs les plus courants~:

\index{syntax}

\begin{enumerate}

% \item Make sure you are not using a Python keyword for a variable name.

\item V\'erifiez que vous n'utilisez pas un mot clef de {\sc Python} comme
nom d'une variable.

\index{keyword}

% \item Check that you have a colon at the end of the header of every
% compound statement, including {\tt for}, {\tt while},
% {\tt if}, and {\tt def} statements.

\item  V\'erifiez que vous avec un point-virgule \`a la fin de l'ent\^ete
de chaque commande compos\'ee comme les {\tt for}, les {\tt while}, les
{\tt if} et les {\tt def}.

\index{header}
\index{colon}

% \item Make sure that any strings in the code have matching
% quotation marks.

\item  V\'erifiez que tous les strings dans le code ont des guimets correspondants.

\index{quotation mark}

% \item If you have multiline strings with triple quotes (single or double), make
% sure you have terminated the string properly.  An unterminated string
% may cause an {\tt invalid token} error at the end of your program,
% or it may treat the following part of the program as a string until it
% comes to the next string.  In the second case, it might not produce an error
% message at all!

\item  Si vous avez des strings multiligne avec des guimets triples (simple ou double),
v\'erifiez que vous avez correctement termin\'e le string.  Un string sans termination
peut donner un erreur de {\tt invalid token} \`a la fin de votre programme
ou \c{c}a pourrait traiter la suite du programmme comme un string jusqu'\`a ce qu'il
trouve un autre string.  Dans ce deuxi\`eme cas, il ne pourrait pas produire
un message d'erreur du tout!

\index{multiline string}
\index{string!multiline}

% \item An unclosed opening operator---\verb+(+, \verb+{+, or
%   \verb+[+---makes Python continue with the next line as part of the
%   current statement.  Generally, an error occurs almost immediately in
%   the next line.

\item  Un \verb+(+, \verb+{+ ou \verb+[+ non ferm\'e a comme
r\'esultat que {\sc Python} cocntinue avec la ligne suivante comme
partie de la commande actuelle.  En g\'en\'erale l'erreur se passe
tout de suite dans la ligne qui suit.

% \item Check for the classic {\tt =} instead of {\tt ==} inside
% a conditional.

\item  V\'erifiez la classique {\tt =} au lieu de {\tt ==}
dans une comparaison.

\index{conditional}

% \item Check the indentation to make sure it lines up the way it
% is supposed to.  Python can handle space and tabs, but if you mix
% them it can cause problems.  The best way to avoid this problem
% is to use a text editor that knows about Python and generates
% consistent indentation.

\item V\'erifiez que l'indentation est coh\'erente.  {\sc Python} peut utiliser
soit des espaces soit des tabulations, mais le mélange des deux peuvent causer 
des problèmes.  
% Vous pouvez indenter
% soit avec des espaces ou avec des tabulations mais c'est mieux de ne pas
% les m\'elanger.  
Chaque niveau doit \^etre d\'eplac\'e par la m\^eme quantit\'e
d'espace \`a gauche.
La meilleure façon d'éviter ce type de problème est d'utiliser un éditeur
de texte qui connaît {\em Python} et donc peut faire l'indentation de manière
automatique.

\index{indentation}
\index{whitespace}

\end{enumerate}

% If nothing works, move on to the next section...
Si rien ne marche, procedez \`a la section suivante...

% ---------------------------------------------------------------------
% \subsection{I keep making changes and it makes no difference.}
\subsection{Mon programme ne tourne pas malgr\'e tous mes efforts.}
% --------------------------------------------------------------

% If the interpreter says there is an error and you don't see it, that
% might be because you and the interpreter are not looking at the same
% code.  Check your programming environment to make sure that the
% program you are editing is the one Python is trying to run.

Si l'interpréteur vous indique un erreur et vous ne le voyez pas,
il est possible que vous et votre interpréteur ne regardent pas
le m\^eme code.  V\'erifiez votre environnement de programmation
pour \^etre vraiment s\^ur que vous modifiez le programme que
{\sc Python} tente \`a ex\'ecuter.  Si vous n'\^etes pas s\^ur,
mettez expr\`es un erreur de syntaxe \'evident au debut de votre
programme.  Maintenant le fa\^{\i}tes tourner (ou l'importer) de
nouveau.  Si l'interpretteur ne trouve pas le nouveau erreur, il
y a probablement quelque chose qui ne va pas avec votre environnement
informatique.

% If you are not sure, try putting an obvious and deliberate syntax
% error at the beginning of the program.  Now run it again.  If the
% interpreter doesn't find the new error, you are not running the
% new code.

% There are a few likely culprits:

Voici une liste des problèmes probables~:

\begin{itemize}

% \item You edited the file and forgot to save the changes before
% running it again.  Some programming environments do this
% for you, but some don't.

\item Vous avez édité le fichier mais vous avez oublié de sauvegarder
avant de faire tourner le programme de nouveau.  Certains environnements
de programmation font ceci pour vous mais d'autres ne le font pas.

% \item You changed the name of the file, but you are still running
% the old name.

\item Vous avez changé le nom du fichier, mais vous tournez toujours
le programme avec son ancien nom.

% \item Something in your development environment is configured
% incorrectly.

\item Il y a quelque chose malconfigurée dans votre environnement de développement.

% \item If you are writing a module and using {\tt import},
% make sure you don't give your module the same name as one
% of the standard Python modules.

\item Si vous écrivez un module et vous utilisez {\tt import}
vérifiez bien que vous n'avez pas donné le module le même nom
qu'un des modules standards de {\sc Python}.

\index{module!reload}
\index{reload function}
\index{function!reload}

% \item If you are using {\tt import} to read a module, remember
% that you have to restart the interpreter or use {\tt reload}
% to read a modified file.  If you import the module again, it
% doesn't do anything.

\item Si vous utilisez {\tt import} pour lire un module, souvenez-vous
que vous devez redemarrer l'interpretteur ou utiliser {\tt reload}
pour lire le fichier modifié.  Si vous importez le module de nouveau,
il ne fera rien.

\end{itemize}

% If you get stuck and you can't figure out what is going on, one
% approach is to start again with a new program like ``Hello, World!,''
% and make sure you can get a known program to run.  Then gradually add
% the pieces of the original program to the new one.

Si rien ne marche plus, une approache est de commencer de nouveau avec
un programme comme {\em Hello, World!} et de v\'erifiez de nouveau
que le programmee marche.  Puis d'ajouter graduellement le reste
du programme sur le quel vous travaillez.

% -------------------------------------------------
% \section{Runtime errors}
\section{Erreur d'ex\'ecution}
% -----------------------------------------------


% Once your program is syntactically correct,
% Python can compile it and at least start running it.  What could
% possibly go wrong?

Si le syntaxe de votre programme est correcte, {\sc Python} peut
l'importer et au moins peut commencer \`a le faire tourner.  Comment
ne peut-il pas marcher maintenant?


% -------------------------------------------------------
% \subsection{My program does absolutely nothing.}
\subsection{Mon programme ne fait strictement rien.}
% ----------------------------------------------------

% This problem is most common when your file consists of functions and
% classes but does not actually invoke anything to start execution.
% This may be intentional if you only plan to import this module to
% supply classes and functions.

La cause la plus courante de ce probl\`eme est que votre fichier comprend
des fonctions et des classes mais ne fait rien pour les appeler et donc
de les faire ex\'ecuter.  Ce pourrait \^etre expr\`es de votre part si
vous ne voulez qu'importer ce module pour avoir des classes et des
fonctions.

% If it is not intentional, make sure that you
% are invoking a function to start execution, or execute one from
% the interactive prompt.  Also see the ``Flow of Execution'' section
% below.

Si ce n'est pas fait expr\`es, v\'erifiez que vous \^etes en train d'appeler une
fonction pour l'ex\'ecuter ou d'ex\'ecuter une \`a partir d'une incitation
interactive.  Aussi voir la section ``S\'equence d'Ex\'ecution'' en bas.


\subsection{My program hangs.}
\index{infinite loop}
\index{infinite recursion}
\index{hanging}

% If a program stops and seems to be doing nothing, it is ``hanging.''
% Often that means that it is caught in an infinite loop or infinite
% recursion.

Si un programme s'arr\^ete sans rien faire, on dit que c'est bloqu\'e.
Souvent \c{c}a veut dire que c'est pris dans une boucle ou dans une
recursion infinie.

\begin{itemize}

% \item If there is a particular loop that you suspect is the
% problem, add a {\tt print} statement immediately before the loop that says
% ``entering the loop'' and another immediately after that says
% ``exiting the loop.''

\item  S'il y a une boucle que vous soupconnez est le probl\`eme, ajoutez
une commande {\tt print} imm\'ediatement avant la boucle qui dit ``\`a l'entr\'ee
de la boucle'' et une autre juste apr\`es qui disait ``\`a la sortie de la boucle.''

% Run the program.  If you get the first message and not the second,
% you've got an infinite loop.  Go to the ``Infinite Loop'' section
% below.

Fa\^{\i}tes tourner le programme.  Si vous avez le premier message et pas le
deuxi\`eme, alors vous avez une boucle infinie.  Allez \`a la section ``Boucle
infinie'' en bas.

% \item Most of the time, an infinite recursion will cause the program
% to run for a while and then produce a ``RuntimeError: Maximum
% recursion depth exceeded'' error.  If that happens, go to the
% ``Infinite Recursion'' section below.

\item   La plupart du temps, une recursion infinie aura comme r\'esultat que
le programme tourne pendant un moment et puis produit le message d'erreur
``RuntimeError: Maximum recursion depth exceeded''.  Si \c{c}a se passe, allez
\`a la section ``Recursion infinie'' en bas.

% If you are not getting this error but you suspect there is a problem
% with a recursive method or function, you can still use the techniques
% in the ``Infinite Recursion'' section.

Si vous n'avez pas ce message d'erreur mais vous pensez que la cause du probl\`eme
est une m\'ethode recursive ou ne fonction, vous pouvez tout le m\`eme utiliser
les techniques dans la section ``Recursion infinie''.

% \item If neither of those steps works, start testing other
% loops and other recursive functions and methods.

\item Si ni l'un ni l'autre de ces \'etapes vous d\'epannent, commencez \`a
tester d'autres boucles et d'autres fonctions et m\'ethodes recursives.

% \item If that doesn't work, then it is possible that
% you don't understand the flow of execution in your program.
% Go to the ``Flow of Execution'' section below.

\item  Si \c{c}a ne marche pas, alors il est possible que vous ne comprenez
pas l'ordre d'ex\'ecution des commandes dans votre programme.  Allez \`a la
section ``S\'equence d'Ex\'ecution'' en bas.

\end{itemize}


% -----------------------------------------------------------------
% \subsubsection{Infinite Loop}
\subsubsection{Boucle infinie }
% -----------------------------------------------------------------
\index{infinite loop}
\index{loop!infinite}
\index{condition}
\index{loop!condition}

% If you think you have an infinite loop and you think you know
% what loop is causing the problem, add a {\tt print} statement at
% the end of the loop that prints the values of the variables in
% the condition and the value of the condition.

Si vous pensez que vous avez affaire \`a une boucle infinie et vous pensez conna\^{\i}tre
la boucle qui cause le probl\`eme, ajoutez \`a la fin de la boucle une commande {\tt print}
pour imprimer toutes les variables conditionnelles et leurs valeurs.

% For example:

Par exemple:

\beforeverb
\begin{verbatim}
while x > 0 and y < 0 :
    # do something to x
    # do something to y

    print  "x: ", x
    print  "y: ", y
    print  "condition: ", (x > 0 and y < 0)
\end{verbatim}
\afterverb
%
% Now when you run the program, you will see three lines of output
% for each time through the loop.  The last time through the
% loop, the condition should be {\tt false}.  If the loop keeps
% going, you will be able to see the values of {\tt x} and {\tt y},
% and you might figure out why they are not being updated correctly.
Puis fa'\^{\i}tes tourner votre programme.  Vous verez les trois
lignes de donn\'ees pour chaque iteration de la boucle.  \`A la
derni\`ere it\'eration la condition doit avoir la valeur {\tt false}.
Si les int\'erations continuent, vous verez les valeurs de {\tt x}
et de {\tt y} qui vous permettrez peut-\^etre de d\'eduire pourquoi
elles ne sont pas mises \`a jour correctement.


% --------------------------------------------------------------
% \subsubsection{Infinite Recursion}
\subsubsection{Recursion infinie}
% ------------------------------------------------------
\index{infinite recursion}
\index{recursion!infinite}

\EN

Most of the time, an infinite recursion will cause the program to run
for a while and then produce a {\tt Maximum recursion depth exceeded}
error.

If you suspect that a function or method is causing an infinite
recursion, start by checking to make sure that there is a base case.
In other words, there should be some condition that will cause the
function or method to return without making a recursive invocation.
If not, then you need to rethink the algorithm and identify a base
case.

If there is a base case but the program doesn't seem to be reaching
it, add a {\tt print} statement at the beginning of the function or method
that prints the parameters.  Now when you run the program, you will see
a few lines of output every time the function or method is invoked,
and you will see the parameters.  If the parameters are not moving
toward the base case, you will get some ideas about why not.


\subsubsection{Flow of Execution}
\index{flow of execution}

If you are not sure how the flow of execution is moving through
your program, add {\tt print} statements to the beginning of each
function with a message like ``entering function {\tt foo},'' where
{\tt foo} is the name of the function.

Now when you run the program, it will print a trace of each
function as it is invoked.


\subsection{When I run the program I get an exception.}
\index{exception}
\index{runtime error}

If something goes wrong during runtime, Python
prints a message that includes the name of the
exception, the line of the program where the problem occurred,
and a traceback.

\index{traceback}

The traceback identifies the function that is currently running,
and then the function that invoked it, and then the function that
invoked {\em that}, and so on.  In other words, it traces the
sequence of function invocations that got you to where you are.  It
also includes the line number in your file where each of these
calls occurs.

The first step is to examine the place in the program where
the error occurred and see if you can figure out what happened.
These are some of the most common runtime errors:

\begin{description}

\item[NameError:]  You are trying to use a variable that doesn't
exist in the current environment.
Remember that local variables are local.  You
cannot refer to them from outside the function where they are defined.

\index{NameError}
\index{TypeError}
\index{exception!NameError}
\index{exception!TypeError}

\item[TypeError:] There are several possible causes:

\begin{itemize}

\item  You are trying to use a value improperly.  Example: indexing
a string, list, or tuple with something other than an integer.

\index{index}

\item There is a mismatch between the items in a format string and
the items passed for conversion.  This can happen if either the number
of items does not match or an invalid conversion is called for.

\index{format operator}
\index{operator!format}

\item You are passing the wrong number of arguments to a function or method.
For methods, look at the method definition and
check that the first parameter is {\tt self}.  Then look at the
method invocation; make sure you are invoking the method on an
object with the right type and providing the other arguments
correctly.

\end{itemize}

\item[KeyError:]  You are trying to access an element of a dictionary
using a key that the dictionary does not contain.

\index{KeyError}
\index{exception!KeyError}
\index{dictionary}

\item[AttributeError:] You are trying to access an attribute or method
that does not exist.  Check the spelling!  You can use
{\tt dir} to list the attributes that do exist.

If an AttributeError indicates that an object has {\tt NoneType},
that means that it is {\tt None}.  One common cause is forgetting
to return a value from a function; if you get to the end of
a function without hitting a {\tt return} statement, it returns
{\tt None}.  Another common cause is using the result from
a list method, like {\tt sort}, that returns {\tt None}.

\index{AttributeError}
\index{exception!AttributeError}

\item[IndexError:] The index you are using
to access a list, string, or tuple is greater than
its length minus one.  Immediately before the site of the error,
add a {\tt print} statement to display
the value of the index and the length of the array.
Is the array the right size?  Is the index the right value?

\index{IndexError}
\index{exception!IndexError}

\end{description}

\index{debugger (pdb)}
\index{Python debugger (pdb)}
\index{pdb (Python debugger)}

The Python debugger ({\tt pdb}) is useful for tracking down
Exceptions because it allows you to examine the state of the
program immediately before the error.  You can read
about {\tt pdb} at \url{docs.python.org/lib/module-pdb.html}.


\subsection{I added so many {\tt print} statements I get inundated with
output.}

\index{print statement}
\index{statement!print}

One of the problems with using {\tt print} statements for debugging
is that you can end up buried in output.  There are two ways
to proceed: simplify the output or simplify the program.

To simplify the output, you can remove or comment out {\tt print}
statements that aren't helping, or combine them, or format
the output so it is easier to understand.

To simplify the program, there are several things you can do.  First,
scale down the problem the program is working on.  For example, if you
are searching a list, search a {\em small} list.  If the program takes
input from the user, give it the simplest input that causes the
problem.

\index{dead code}

Second, clean up the program.  Remove dead code and reorganize the
program to make it as easy to read as possible.  For example, if you
suspect that the problem is in a deeply nested part of the program,
try rewriting that part with simpler structure.  If you suspect a
large function, try splitting it into smaller functions and testing them
separately.

\index{testing!minimal test case}
\index{test case, minimal}

Often the process of finding the minimal test case leads you to the
bug.  If you find that a program works in one situation but not in
another, that gives you a clue about what is going on.

Similarly, rewriting a piece of code can help you find subtle
bugs.  If you make a change that you think doesn't affect the
program, and it does, that can tip you off.


\section{Semantic errors}
\index{semantic error}
\index{error!semantic}

In some ways, semantic errors are the hardest to debug,
because the interpreter provides no information
about what is wrong.  Only you know what the program is supposed to
do.

The first step is to make a connection between the program
text and the behavior you are seeing.  You need a hypothesis
about what the program is actually doing.  One of the things
that makes that hard is that computers run so fast.

You will often wish that you could slow the program down to human
speed, and with some debuggers you can.  But the time it takes to
insert a few well-placed {\tt print} statements is often short compared to
setting up the debugger, inserting and removing breakpoints, and
``stepping'' the program to where the error is occurring.

\subsection{My program doesn't work.}

You should ask yourself these questions:

\begin{itemize}

\item Is there something the program was supposed to do but
which doesn't seem to be happening?  Find the section of the code
that performs that function and make sure it is executing when
you think it should.

\item Is something happening that shouldn't?  Find code in
your program that performs that function and see if it is
executing when it shouldn't.

\item Is a section of code producing an effect that is not
what you expected?  Make sure that you understand the code in
question, especially if it involves invocations to functions or methods in
other Python modules.  Read the documentation for the functions you invoke.
Try them out by writing simple test cases and checking the results.

\end{itemize}

In order to program, you need to have a mental model of how
programs work.  If you write a program that doesn't do what you expect,
very often the problem is not in the program; it's in your mental
model.

\index{model, mental}
\index{mental model}

The best way to correct your mental model is to break the program
into its components (usually the functions and methods) and test
each component independently.  Once you find the discrepancy
between your model and reality, you can solve the problem.

Of course, you should be building and testing components as you
develop the program.  If you encounter a problem,
there should be only a small amount of new code
that is not known to be correct.


\subsection{I've got a big hairy expression and it doesn't
do what I expect.}

\index{expression!big and hairy}
\index{big, hairy expression}

Writing complex expressions is fine as long as they are readable,
but they can be hard to debug.  It is often a good idea to
break a complex expression into a series of assignments to
temporary variables.

For example:

\beforeverb
\begin{verbatim}
self.hands[i].addCard(self.hands[self.findNeighbor(i)].popCard())
\end{verbatim}
\afterverb
%
This can be rewritten as:

\beforeverb
\begin{verbatim}
neighbor = self.findNeighbor(i)
pickedCard = self.hands[neighbor].popCard()
self.hands[i].addCard(pickedCard)
\end{verbatim}
\afterverb
%
The explicit version is easier to read because the variable
names provide additional documentation, and it is easier to debug
because you can check the types of the intermediate variables
and display their values.

\index{temporary variable}
\index{variable!temporary}
\index{order of operations}
\index{precedence}

Another problem that can occur with big expressions is
that the order of evaluation may not be what you expect.
For example, if you are translating the expression
$\frac{x}{2 \pi}$ into Python, you might write:

\beforeverb
\begin{verbatim}
y = x / 2 * math.pi
\end{verbatim}
\afterverb
%
That is not correct because multiplication and division have
the same precedence and are evaluated from left to right.
So this expression computes $x \pi / 2$.

A good way to debug expressions is to add parentheses to make
the order of evaluation explicit:

\beforeverb
\begin{verbatim}
 y = x / (2 * math.pi)
\end{verbatim}
\afterverb
%
Whenever you are not sure of the order of evaluation, use
parentheses.  Not only will the program be correct (in the sense
of doing what you intended), it will also be more readable for
other people who haven't memorized the rules of precedence.


\subsection{I've got a function or method that doesn't return what I
expect.}
\index{return statement}
\index{statement!return}

If you have a {\tt return} statement with a complex expression,
you don't have a chance to print the {\tt return} value before
returning.  Again, you can use a temporary variable.  For
example, instead of:

\beforeverb
\begin{verbatim}
return self.hands[i].removeMatches()
\end{verbatim}
\afterverb
%
you could write:

\beforeverb
\begin{verbatim}
count = self.hands[i].removeMatches()
return count
\end{verbatim}
\afterverb
%
Now you have the opportunity to display the value of
{\tt count} before returning.


\subsection{I'm really, really stuck and I need help.}

First, try getting away from the computer for a few minutes.
Computers emit waves that affect the brain, causing these
symptoms:

\begin{itemize}

\item Frustration and rage.

\index{frustration}
\index{rage}
\index{debugging!emotional response}
\index{emotional debugging}

\item Superstitious beliefs (``the computer hates me'') and
magical thinking (``the program only works when I wear my
hat backward'').

\index{debugging!superstition}
\index{superstitious debugging}

\item Random walk programming (the attempt to program by writing
every possible program and choosing the one that does the right
thing).

\index{random walk programming}
\index{development plan!random walk programming}

\end{itemize}

If you find yourself suffering from any of these symptoms, get
up and go for a walk.  When you are calm, think about the program.
What is it doing?  What are some possible causes of that
behavior?  When was the last time you had a working program,
and what did you do next?

Sometimes it just takes time to find a bug.  I often find bugs
when I am away from the computer and let my mind wander.  Some
of the best places to find bugs are trains, showers, and in bed,
just before you fall asleep.


\subsection{No, I really need help.}

It happens.  Even the best programmers occasionally get stuck.
Sometimes you work on a program so long that you can't see the
error.  A fresh pair of eyes is just the thing.

Before you bring someone else in, make sure you are prepared.
Your program should be as simple
as possible, and you should be working on the smallest input
that causes the error.  You should have {\tt print} statements in the
appropriate places (and the output they produce should be
comprehensible).  You should understand the problem well enough
to describe it concisely.

When you bring someone in to help, be sure to give
them the information they need:

\begin{itemize}

\item If there is an error message, what is it
and what part of the program does it indicate?

\item What was the last thing you did before this error occurred?
What were the last lines of code that you wrote, or what is
the new test case that fails?

\item What have you tried so far, and what have you learned?

\end{itemize}

When you find the bug, take a second to think about what you
could have done to find it faster.  Next time you see something
similar, you will be able to find the bug more quickly.

Remember, the goal is not just to make the program
work.  The goal is to learn how to make the program work.
