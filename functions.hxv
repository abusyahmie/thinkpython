\label{funcchap}

%\section{Function calls}
\section{Appel de fonctions}
\label{functionchap}
%\index{function call}
\index{fonction (appel de)}

%In the context of programming, a {\bf function} is a named sequence of
%statements that performs a computation.  When you define a function,
%you specify the name and the sequence of statements.  Later, you can
%``call'' the function by name.  
%We have already seen one example of a {\bf function call}:

En programmation, une {\bf fonction} est une suite d'expressions qui r\'ealisent
un calcul, et \`a laquelle on donne un nom. Lorsque vous d\'efinissez une
fonction vous devez indiquer son nom et la suite de d'expressions. Ensuite,
il est possible d'``appeler'' la fonction par son nom.
Nous avons d\'ej\`a vu un exemple d'appel de fonction:

\beforeverb
\begin{verbatim}
>>> type(32)
<type 'int'>
\end{verbatim}
\afterverb
%
%The name of the function is {\tt type}.  The expression in parentheses
%is called the {\bf argument} of the function.  The result, for this
%function, is the type of the argument.

Le nom de la fonction est {\tt type}. L'expression entre parenth\`eses
est appel\'e l'{\bf argument} de la fonction. Le r\'esultat, pour cette
fonction, est le type de l'argment. 

\index{parentheses!argument in}

%It is common to say that a function ``takes'' an argument and ``returns''
%a result.  The result is called the {\bf return value}.

On dit commun`ement qu'une fonction ``prend'' un argument et ``renvoie''
un r\'esultat. Ce r\'esultat est appel\'e \textbf{valeur de renvoi}.

%\index{argument}
%\index{return value}
\index{argument}
\index{valeur de renvoi}


\section{Type conversion functions}
\index{conversion!type}
\index{type conversion}

% from Elkner:
% comment on whether these things are _really_ functions?
% use max as an example of a built-in?

% my reply:
% they are on the list of ``built-in functions'' so I am
% willing to call them functions.

%Python provides built-in functions that convert values
%from one type to another.  The {\tt int} function takes any value and
%converts it to an integer, if it can, or complains otherwise:

Python fournit des fonctions intrins\`eques qui pemettent de
convertir des valeurs d'un type vers un autre. Par exemple la
fonction {\tt int} prend n'importe quelle valeur et la convertit
en entier, lorsque c'est possible, et proteste dans le cas contraire :

%\index{int function}
%\index{function!int}
\index{int (fonction)}
\index{fonction!int}

\beforeverb
\begin{verbatim}
>>> int('32')
32
>>> int('Bonjour')
ValueError: invalid literal for int(): Bonjour\end{verbatim}
\afterverb
%
%{\tt int} can convert floating-point values to integers, but it
%doesn't round off; it chops off the fraction part:

{\tt int} peut convertir des nombres r\'eels (en virgule flottante) 
en entier, mais sans faire d'arrondi ; la partie fractionnaire est
supprim\'ee.

\beforeverb
\begin{verbatim}
>>> int(3.99999)
3
>>> int(-2.3)
-2
\end{verbatim}
\afterverb
%
%{\tt float} converts integers and strings to floating-point
%numbers:

{\tt float} converti des entier ainsi que des cha\^ines de caract\`eres
en nombres en virgule flottante.

%\index{float function}
%\index{function!float}
\index{float (fonction)}
\index{fonction!float}

\beforeverb
\begin{verbatim}
>>> float(32)
32.0
>>> float('3.14159')
3.14159
\end{verbatim}
\afterverb
%
%Finally, {\tt str} converts its argument to a string:

Enfin, {\tt str} converti son argument en une cha\^ine de caract\`eres :

%\index{str function}
%\index{function!str}
\index{str (fonction)}
\index{fonction!str}

\beforeverb
\begin{verbatim}
>>> str(32)
'32'
>>> str(3.14159)
'3.14159'
\end{verbatim}
\afterverb
%

%\section{Math functions}
%\index{math function}
%\index{function, math}
\section{Fonctions math\'ematiques}
\index{fonctions math\'ematiques}
\index{fonctions, math}

%Python has a math module that provides most of the familiar
%mathematical functions.  A {\bf module} is a file that contains a
%collection of related functions.

Python inclut un module qui fournit la plupart
des fonctions math\'ematiques usuelles. Un \textbf{module} est
un fichier qui comprends un ensemble de fonctions ayant
un lien entre elles.

%\index{module}
%\index{module object}
\index{module}
\index{objet module}

%Before we can use the module, we have to import it:
Avant d'utiliser un module, il faut l'importer :

\beforeverb
\begin{verbatim}
>>> import math
\end{verbatim}
\afterverb
%
%This statement creates a {\bf module object} named math.  If
%you print the module object, you get some information about it:

Cette expression cr\'ee un \textbf{objet module} appel\'e {\tt math}.
Si vous imprimez  (\`a l'aide de la fonction {\tt print}) cet objet module,
vous pouvez obtenir des informations Ã  son sujet:

\beforeverb
\begin{verbatim}
>>> print math
<module 'math' from '/usr/lib/python2.5/lib-dynload/math.so'>
\end{verbatim}
\afterverb
%
%The module object contains the functions and variables defined in the
%module.  To access one of the functions, you have to specify the name
%of the module and the name of the function, separated by a dot (also
%known as a period).  This format is called {\bf dot notation}.

L'objet module contient les fonctions et variables d\'efinies dans
le module. Pour y acc\'eder il faut sp\'ecifier le nom du module
et le nom de la fonction, s\'epar\'es par un point.
% NDT - Vincent : je ne sais pas comment transcrire 'dot notation'
% de maniere utile ?

%\index{dot notation}

\beforeverb
\begin{verbatim}
>>> rapport = signal / bruit
>>> decibels = 10 * math.log10(rapport)

>>> radians = 0.7
>>> hauteur = math.sin(radians)
\end{verbatim}
\afterverb
%
%The first example computes the logarithm base 10 of the
%signal-to-noise ratio.  The math module also provides a
%function called {\tt log} that computes logarithms base {\tt e}.

Le premier exemple calcule le logarithme en base 10
d'un rapport signal sur bruit. Le module math fournit
\'egalement une fonction appel\'ee {\tt log} qui calcule
le logarithme naturel (en base {\tt e}).

%\index{log function}
%\index{function!log}
%\index{sine function}
%\index{radian}
%\index{trigonometric function}
%\index{function, trigonometric}

\index{log (fonction)}
\index{fonction!log}
\index{sinus (fonction)}
\index{radian}
\index{fonction trignom\'etrique}
\index{fonction, trignom\'etrie}

%The second example finds the sine of {\tt radians}.  The name of the
%variable is a hint that {\tt sin} and the other trigonometric
%functions ({\tt cos}, {\tt tan}, etc.)  take arguments in radians. To
%convert from degrees to radians, divide by 360 and multiply by $2
%\pi$:

Le second exemple calcule le sinus de la variable {\tt radians}. Le nom
de cette variable est choisi de mani\`ere \`a rappeler que {\tt sin}
ainsi que les autres fonctions trigonom\'etriques ({\tt cos}, {\tt tan}, etc.)
prennent des radians comme argument. Pour convertir de degr\'es en radians,
il suffit de diviser par 360 et de multiplier par $2\pi$:

\beforeverb
\begin{verbatim}
>>> degrees = 45
>>> radians = degrees / 360.0 * 2 * math.pi
>>> math.sin(radians)
0.707106781187
\end{verbatim}
\afterverb

%The expression {\tt math.pi} gets the variable {\tt pi} from the math
%module.  The value of this variable is an approximation
%of $\pi$, accurate to about 15 digits.

L'expression {\tt math.pi} extrait la variable {\tt pi} du module math.
La valeur de cette variable est une approximation de $\pi$, avec
environ 15 chiffre significatifs.

\index{pi}

%If you know
%your trigonometry, you can check the previous result by comparing it to
%the square root of two divided by two:

Si vous connaissez bien vos formules trigonom\'etriques, vous pouvez
v\'erifier le r\'esultat pr\'ec\`edent en le comparant \'a
$\frac{\sqrt(2)}{2}$:

%\index{sqrt function}
%\index{function!sqrt}
\index{sqrt (fonction)}
\index{racine carr\'ee (fonction)}
\index{fonction!sqrt}

\beforeverb
\begin{verbatim}
>>> math.sqrt(2) / 2.0
0.707106781187
\end{verbatim}
\afterverb
%

\section{Composition}
\index{composition}

%So far, we have looked at the elements of a program---variables,
%expressions, and statements---in isolation, without talking about how to
%combine them.

Jusqu'ici nous nous sommes int\'eress\'es \'a des \'el\'ements d'un
programme --variables, expressions, instructions-- de mani\`ere isol\'ee, sans
discuter de la mani\`ere de les associer.

%One of the most useful features of programming languages is their
%ability to take small building blocks and {\bf compose} them.  For
%example, the argument of a function can be any kind of expression,
%including arithmetic operators:

Une des facult\'es les plus utiles des languages de programmation
est leur capacit\'e \'a \textbf{combiner} des unit\'es \'el\'ementaires 
de programme. Par exemple, l'argument d'une fonction peut \^etre
n'importe quel type d'expression, comme le r\'esultat d'op\'erations
arithm\'etiques.

\beforeverb
\begin{verbatim}
x = math.sin(degres / 360.0 * 2 * math.pi)
\end{verbatim}
\afterverb

%And even function calls:
Et m\^eme des appels de fonctions :

\beforeverb
\begin{verbatim}
x = math.exp(math.log(x+1))
\end{verbatim}
\afterverb
%
%Almost anywhere you can put a value, you can put an arbitrary
%expression, with one exception: the left side of an assignment
%statement has to be a variable name.  Any other expression on the left
%side is a syntax error\footnote{We will see exceptions to this rule
%later.}.

\'A chaque endroit o\`u il est posible de mettre une valeur,
il est possible de la remplacer par une expression quelconque,
avec une seule exception : le cot\'e gauche d'une instruction
\textbf{doit} \^etre un nom de variable. Tout autre expression
\`a gauche constitue une erreur de syntaxe.\footnote{Nous verrons
plus tard qu'il existe des exceptions \`a cette r\`egle.}.

\beforeverb
\begin{verbatim}
>>> minutes = heures * 60                 # correct
>>> heures * 60 = minutes                 # incorrect!
SyntaxError: can't assign to operator
\end{verbatim}
\afterverb
%
\index{SyntaxError}
\index{Erreur de syntaxe}
\index{exception!Erreur de syntaxe}


%\section{Adding new functions}
\section{Ajout de nouvelles fonctions}

%So far, we have only been using the functions that come with Python,
%but it is also possible to add new functions.
%A {\bf function definition} specifies the name of a new function and
%the sequence of statements that execute when the function is called.

Jusqu'ici nous n'avons utilis\'e que des fonctions inclues
dans le langage Python, mais il est posiible d'en ajouter de 
nouvelles. La \textbf{d\'efinition d'une fonction} comprend
le nom de la nouvelle fonction ainsi que la suite d'instructions
\`a \'ex\'ecuter lorsque la fonction est appel\'ee.

%\index{function}
%\index{function definition}
%\index{definition!function}
\index{fonction}
\index{fonction (d\'efinition d'une)}
\index{d\'efinition!fonction}

%Here is an example:
Voici un exemple :\footnote{NdT : les paroles sont extraites d'une
chanson des Monty Python \textit{The Lumberjack Song} 
(http:en.wikipedia.org/wiki/The\_Lumberjack\_Song), la 
Chanson du B\^ucheron. Elle est chant\'ee dans un \'episode
du \textit{Monty Python Flying Circus}. Dans le monde francophone
leur films "Sacr\'e Graal", "La vie de Brian" et "Le sens de la vie"
sont plus connus que cette s\'erie.}
%\beforeverb
%\begin{verbatim}
%def print_lyrics():
%    print "I'm a lumberjack, and I'm okay."
%    print "I sleep all night and I work all day."
%\end{verbatim}
%\afterverb

%NDT Vincent: Je ne vais pas traduire les Monthy Python !
\beforeverb
\begin{verbatim}
def ecrit_parole():
    print "I'm a lumberjack, and I'm okay."
    print "I sleep all night and I work all day."
\end{verbatim}
\afterverb

%{\tt def} is a keyword that indicates that this is a function
%definition.  The name of the function is \verb"print_lyrics".  The
%rules for function names are the same as for variable names: letters,
%numbers and some punctuation marks are legal, but the first character
%can't be a number.  You can't use a keyword as the name of a function,
%and you should avoid having a variable and a function with the same
%name.
Le mot-clef {\tt def} indique le d\'ebut de la d\'efinition de la
fonction. Le nom de la fonction est \verb"ecrit_parole". Les r\`egles
r\'egissant les noms de fonctions sont les m\^mes que pour les
noms de variables : des lettres, des nombres et certains
caractÃ¨res de ponctuation sont acceptÃ©s, mais le premier
caract\`ere ne peut \^etre un nombre. Il n'est pas possible d'utiliser
un mot-clef comme nom de fonction, et il est pr\'ef\'erable
d'\'eviter d'utiliser une variable et une fonction ayant le m\^eme
nom.

%\index{def keyword}
%\index{keyword!def}
%\index{argument}
\index{def mot-clef}
\index{mot-clef!def}
\index{argument}

%The empty parentheses after the name indicate that this function
%doesn't take any arguments.

Les parenth\`eses vides apr\`es le nom indiquent que cette
fonction ne prend aucun argument.

%\index{parentheses!empty}
%\index{header}
%\index{body}
%\index{indentation}
%\index{colon}

\index{parenth\`eses!vide}
\index{en-t\^ete}
\index{corps}
\index{indentation}
\index{colonne}

%The first line of the function definition is called the {\bf header};
%the rest is called the {\bf body}.  The header has to end with a colon
%and the body has to be indented.  By convention, the indentation is
%always four spaces (see Section~\ref{editor}).  The body can contain
%any number of statements.

La premi\`ere ligne de la d\'efinition d'une fonction est
appel\'ee l'\textbf{en-t\^ete} ; le reste est appel\'e le \textbf{corps}.
L'en-t\^ete doit finir par un symbole deux-points ({\tt:}), et le
corps doit \^etre indent\'e. Par convention, l'indentation est toujours
de quatre espaces\footnote{NdT: il s'agit de la convention la plus courante,
utilis\'ee dans ce livre. Elle n'est pas obligatoire mais il est important
de toujours suivre la m\^eme convention.} (voir la section~\ref{editor}).
Le corps peut comprendre un nombre quelconque d'instructions.

%The strings in the print statements are enclosed in double
%quotes.  Single quotes and double quotes do the same thing;
%most people use single quotes except in cases like this where
%a single quote (which is also an apostrophe) appears in the string.

Les cha\^ines de caract\`ere dans les instructions {\tt print}
sont donn\'ees entre des guillemets doubles. Les guillemets
simples et doubles sont equivalents ; la plupart des gens
utilisent des guillemets simples, sauf lorsqu'un guillemet
simple (qui repr\'esente aussi une apostrophe) appara\^it dans
la cha\^ine de caract\`eres.

%\index{ellipses}
%If you type a function definition in interactive mode, the interpreter
%prints ellipses ({\em ...}) to let you know that the definition
%isn't complete:

\index{points de suspension}
Si vous tapez la dÃ©finition d'une fonction en mode interactif,
l'interpr\'eteur imprimera des points de suspension ({\em ...})
pour vous indiquer que la d\'efinition n'est pas termin\'ee :

%\beforeverb
%\begin{verbatim}
%>>> def print_lyrics():
%...     print "I'm a lumberjack, and I'm okay."
%...     print "I sleep all night and I work all day."
%...
%\end{verbatim}
%\afterverb

\beforeverb
\begin{verbatim}
>>> def ecrit_parole():
...     print "I'm a lumberjack, and I'm okay."
...     print "I sleep all night and I work all day."
...
\end{verbatim}
\afterverb

%
%To end the function, you have to enter an empty line (this is
%not necessary in a script).

Pour terminer la fonction vous devez entrer une ligne vide
(ce n'est pas n\'ecessaire dans un script).

%Defining a function creates a variable with the same name.

D\'efinir une fonction cr\'ee en fait une variable qui
a le m\^eme nom que la fonction.

%\beforeverb
%\begin{verbatim}
%>>> print print_lyrics
%<function print_lyrics at 0xb7e99e9c>
%>>> print type(print_lyrics)
%<type 'function'>
%\end{verbatim}
%\afterverb

\beforeverb
\begin{verbatim}
>>> print ecrit_parole
<function ecrit_parole at 0xb7e99e9c>
>>> print type(ecrit_parole)
<type 'function'>
\end{verbatim}
\afterverb
%

%The value of \verb"print_lyrics" is a {\bf function object}, which
%has type \verb"'function'".

La valeur de \verb"ecrit_parole" corredpond \`a un objet fonction,
qui a le type \verb"'function'".

%\index{function object}
%\index{object!function}
\index{objet fonction}
\index{objet!fonction}

%The syntax for calling the new function is the same as
%for built-in functions:

La syntaxe pour appeler une nouvelle fonction est la m\^eme
que pour une fonction intrins\`eque:

%\beforeverb
%\begin{verbatim}
%>>> print_lyrics()
%I'm a lumberjack, and I'm okay.
%I sleep all night and I work all day.
%\end{verbatim}
%\afterverb

\beforeverb
\begin{verbatim}
>>> ecrit_parole()
I'm a lumberjack, and I'm okay.
I sleep all night and I work all day.
\end{verbatim}
\afterverb

%Once you have defined a function, you can use it inside another
%function.  For example, to repeat the previous refrain, we could write
%a function called \verb"repeat_lyrics":

Lorsqu'une fonction a \'et\'e d\'efinie, il est possible de l'utiliser
dans une autre fonction. Par exemple, pour r\'ep\'eter le refrain
pr\'ec\'edent, nous pouvons \'ecrire une fonction \verb"repete_paroles" :

%\beforeverb
%\begin{verbatim}
%def repeat_lyrics():
%    print_lyrics()
%    print_lyrics()
%\end{verbatim}
%\afterverb

\beforeverb
\begin{verbatim}
def repete_paroles():
    ecrit_parole()
    ecrit_parole()
\end{verbatim}
\afterverb

%And then call \verb"repeat_lyrics":

Et nous pouvons ensuite appeler \verb"repete_paroles" :

%\beforeverb
%\begin{verbatim}
%>>> repeat_lyrics()
%I'm a lumberjack, and I'm okay.
%I sleep all night and I work all day.
%I'm a lumberjack, and I'm okay.
%I sleep all night and I work all day.
%\end{verbatim}
%\afterverb

\beforeverb
\begin{verbatim}
>>> \verb"repete_paroles"()
I'm a lumberjack, and I'm okay.
I sleep all night and I work all day.
I'm a lumberjack, and I'm okay.
I sleep all night and I work all day.
\end{verbatim}
\afterverb

%But that's not really how the song goes.

Mais cela ne correspond pas Ã  la chanson !

%\section{Definitions and uses}
%\index{function definition}
\section{D\'efinitions et usages}
\index{fonction (d\'efinition)}

%Pulling together the code fragments from the previous section, the
%whole program looks like this:

En assemblant les morceaux de code du paragraphe pr\'ec\'edent,
le programme complet ressemble \`a cela :

%\beforeverb
%\begin{verbatim}
%def print_lyrics():
%    print "I'm a lumberjack, and I'm okay."
%    print "I sleep all night and I work all day."
%
%def repeat_lyrics():
%    print_lyrics()
%    print_lyrics()
%
%repeat_lyrics()
%\end{verbatim}
%\afterverb
\beforeverb
\begin{verbatim}
def ecrit_parole():
    print "I'm a lumberjack, and I'm okay."
    print "I sleep all night and I work all day."

def repete_paroles():
    ecrit_parole()
    ecrit_parole()

repete_paroles()
\end{verbatim}
\afterverb

%This program contains two function definitions: \verb"print_lyrics" and
%\verb"repeat_lyrics".  Function definitions get executed just like other
%statements, but the effect is to create function objects.  The statements
%inside the function do not get executed until the function is called, and
%the function definition generates no output.

Ce programme comprend deux d\'efinitions de fonctions : \verb"ecrit_parole"
et \verb"repete_paroles". Les d\'efinitions de fonctions sont \'ex\'ecut\'ees
comme n'importe quelle instruction, mais leur effet est de cr\'eer des
objets fonction. Les instructions \`a l'int\'erieur de chaque fonction ne sont
pas \'ex\'ecut\'ees tant que la fonction n'est pas appell\'ee, et en
cons\'equence la d\'efinition de la fonction n'\'ecrit rien \`a l'\'ecran.

%\index{use before def}
% NdT Vincent ??

%As you might expect, you have to create a function before you can
%execute it.  In other words, the function definition has to be
%executed before the first time it is called.

Comme vous pouvez vous y attendre, il est n\'ecessaire de cr\'eer
une fonction avant de l'\'ex\'ecuter. En d'autres termes, la
d\'efinition de la fonction doit \^etre \'ex\'ecut\'ee avant
le premier appel \`a la fonction.

\begin{ex}
%Move the last line of this program
%to the top, so the function call appears before the definitions. Run 
%the program and see what error
%message you get.
D\'eplacez la derni\`ere ligne de ce programme au d\'ebut, de mani\`ere
\`a ce que l'appel de la fonction aparaisse avant les d\'efinitions.
Ex\'ecutez le programme obtenu et voyez quelle message d'erreur vous obtenez.
\end{ex}

\begin{ex}
%Move the function call back to the bottom
%and move the definition of \verb"print_lyrics" after the definition of
%\verb"repeat_lyrics".  What happens when you run this program?
Re-d\'eplacez l'appel de la fonction en bas et d\'eplacez la d\'efinition
de \verb"repete_paroles". Que ce passe-t-il \`a l\'ex\'ecution de ce
programme ?
\end{ex}


%\section{Flow of execution}
%\index{flow of execution}
\section{Flux d'\'ex\'ecution}
\index{flux d'\'ex\'ecution}

%In order to ensure that a function is defined before its first use,
%you have to know the order in which statements are executed, which is
%called the {\bf flow of execution}.

Pour s'assurer qu'une fonction est d\'efinie avant sa premi\`ere
utilisation, il est n\'ecessaire de conna\^itre l'ordre dans
lequel les instructions seront \'ex\'ecut\'ees, ce qu'on
appelle le \textbf{flux d'\'ex\'ecution}.

%Execution always begins at the first statement of the program.
%Statements are executed one at a time, in order from top to bottom.

L'\'ex\'ecution commence toujours \`a la premi\`ere instruction
du programme. Les instructions sont \'ex\'ecut\'ees une par une,
du d\'ebut \`a la fin.

%Function definitions do not alter the flow of execution of the
%program, but remember that statements inside the function are not
%executed until the function is called.

Les d\'efinitions de fonctions ne modifient pas le flux d'\'ex\'ecution
du programme, mais il ne faut pas oublier que les instructions \`a
l'int\'erieur d'une fonction ne sont pas \'ex\'ecut\'ees avant
que la fonction soit appell\'ee.

%A function call is like a detour in the flow of execution. Instead of
%going to the next statement, the flow jumps to the body of
%the function, executes all the statements there, and then comes back
%to pick up where it left off.

Un appel de fonction est comme un d\'etour dans le flux d'\'ex\'ecution.
Au lieu d'aller \`a l'instruction suivante, le flux saute dans le corps
de la fonction, \'ex\'ecute toutes les instructions, puis continue
le programme l\`a o\`u il l'avait laiss\'e.

%That sounds simple enough, until you remember that one function can
%call another.  While in the middle of one function, the program might
%have to execute the statements in another function. But while
%executing that new function, the program might have to execute yet
%another function!

Cela semble simple, mais il faut se rappeler qu'une fonction peut
en appeler une autre. Au milieu d'une fonction, le programme
peut avoir \`a \'ex\'ecuter des instructions d\`a l'int\'erieur
d'une autre fonction. Et dans cette nouvelle fonction, le programme
pourrait encore devoir appeler une autre fonction...

%Fortunately, Python is good at keeping track of where it is, so each
%time a function completes, the program picks up where it left off in
%the function that called it.  When it gets to the end of the program,
%it terminates.

Heureusement, Python arrive tr\`es bien \`a se rappeler du chemin
parcouru, de mani\`ere \`a ce que chaque fois que l'appel \`a 
une fonction est termin\'e, le programme reprend l\`a o\`u
la fonction avait \'et\'e appell\'ee. Une fois arriv\'e \`a la
fin du programme, il s'arr\^ete.

%What's the moral of this sordid tale?  When you read a program, you
%don't always want to read from top to bottom.  Sometimes it makes
%more sense if you follow the flow of execution.

Quelle est la morale de cette sombre histoire ? Lorsque vous lisez un
programme, ce n'est pas forc\'ement une bonne id\'ee de lire de haut
en bas. Il est parfois plus logique de suivre le flux d'\'ex\'ecution.

%\section{Parameters and arguments}
%\label{parameters}
%\index{parameter}
%\index{function parameter}
%\index{argument}
%\index{function argument}
\section{Param\`etres et arguments}
\label{parameters}
\index{param\`etres}
\index{param\`etre d'une fonction}
\index{argument}
\index{argument d'une fonction}

%Some of the built-in functions we have seen require arguments.  For
%example, when you call {\tt math.sin} you pass a number
%as an argument.  Some functions take more than one argument:
%{\tt math.pow} takes two, the base and the exponent.

Certaines fonctions intrins\`eques que nous avons d\'ej\`a 
rencontr\'ees demandent des arguments. Par exemple, quand
vous appellez {\tt math.sin} vous passez un nombre comme argument.
Certaines fonctions requi\`erent plus d'un argument :
{\tt math.pow} en prends deux, la base et l'exposant.

%Inside the function, the arguments are assigned to
%variables called {\bf parameters}.  Here is an example of a
%user-defined function that takes an argument:

A l'int\'erieur de la fonction, les arguments sont affect\'es
\`a des variables appel\'ees \textbf{param\`etres}. Voici
un exemple d'une fonction d\'efinie par un utilisateur
qui prend un argument :

%\index{parentheses!parameters in}
\index{parenth\`eses!param\`etres dans}

%\beforeverb
%\begin{verbatim}
%def print_twice(bruce):
%    print bruce
%    print bruce
%\end{verbatim}
%\afterverb

\beforeverb
\begin{verbatim}
def ecrit_deux_fois(toto):
    print toto
    print toto
\end{verbatim}
\afterverb

%This function assigns the argument to a parameter
%named {\tt bruce}.  When the function is called, it prints the value of
%the parameter (whatever it is) twice.
%
%This function works with any value that can be printed.

Cette fonction affecte un argument \`a un param\`etre
appel\'e {\tt toto}. Quand la fonction est appell\'ee, elle
imprime la valeur du param\`etre (quelle qu'elle soit)
deux fois.

%\beforeverb
%\begin{verbatim}
%>>> print_twice('Spam')
%Spam
%Spam
%>>> print_twice(17)
%17
%17
%>>> print_twice(math.pi)
%3.14159265359
%3.14159265359
%\end{verbatim}
%\afterverb

\beforeverb
\begin{verbatim}
>>> ecrit_deux_fois('Pourriel')
Pourriel
Pourriel
>>> ecrit_deux_fois(17)
17
17
>>> ecrit_deux_fois(math.pi)
3.14159265359
3.14159265359
\end{verbatim}
\afterverb
%The same rules of composition that apply to built-in functions also
%apply to user-defined functions, so we can use any kind of expression
%as an argument for \verb"print_twice":

Les r\`egles de composition qui s'appliquent aux fonctions
intrins\`eques s'appliquent \'egalement \`a celles d\'efinies
par l'utilisateur. Il est ainsi possible d'utiliser n'importe quelle
expression comme argument de \verb"ecrit_deux_fois" :

\index{composition}

%\beforeverb
%\begin{verbatim}
%>>> print_twice('Spam '*4)
%Spam Spam Spam Spam
%Spam Spam Spam Spam
%>>> print_twice(math.cos(math.pi))
%-1.0
%-1.0
%\end{verbatim}
%\afterverb
\beforeverb
\begin{verbatim}
>>> ecrit_deux_fois('Pourriel '*4)
Pourriel Pourriel Pourriel Pourriel
Pourriel Pourriel Pourriel Pourriel
>>> ecrit_deux_fois(math.cos(math.pi))
-1.0
-1.0
\end{verbatim}
\afterverb

%The argument is evaluated before the function is called, so
%in the examples the expressions \verb"'Spam '*4" and
%{\tt math.cos(math.pi)} are only evaluated once.

L'argument est \'evalu\'e avant que la fonction soit appell\'ee,
ainsi dans les exemples les expressions\verb"'Pourriel '*4"
et \verb"math.cos(math.pi)" ne sont \'ex\'ecut\'ees qu'une seule fois.

\index{argument}

%You can also use a variable as an argument:

Il est \'egalement possible d'utiliser une variable comme 
argument\footnote{NdT \textit{Eric the Half-a-Bee} est une autre chanson
des Monty Python.} :

%\beforeverb
%\begin{verbatim}
%>>> michael = 'Eric, the half a bee.'
%>>> print_twice(michael)
%Eric, the half a bee.
%Eric, the half a bee.
%\end{verbatim}
%\afterverb

\beforeverb
\begin{verbatim}
>>> michael = 'Eric, the half a bee.'
>>> ecrit_deux_fois(michael)
Eric, the half a bee.
Eric, the half a bee.
\end{verbatim}
\afterverb

%The name of the variable we pass as an argument ({\tt michael}) has
%nothing to do with the name of the parameter ({\tt bruce}).  It
%doesn't matter what the value was called back home (in the caller);
%here in \verb"print_twice", we call everybody {\tt bruce}.

Le nom de la variable pass\'ee comme argument {\tt michael}
d'a rien \`a voir avec le nom du param\`etre {\tt toto}. Le
nom avec lequel la valeur \'etait appel\'ee \`a l'origine
(d'o\`u la fonction a \'et\'e appel\'ee) ; dans 
\verb"ecrit_deux_fois", toute les valeurs pass\'ees \`a la fonction
sont appell\'ees \verb"toto".

%\section{Variables and parameters are local}
%\index{local variable}
%\index{variable!local}

\section{Variables et param\`etres are sont locaux}
\index{variable locale}
\index{variable!locale}

%When you create a variable inside a function, it is {\bf local},
%which means that it only
%exists inside the function.  For example:

Lorsque vous cr\'eez une variable \`a l'int\'erieur d'une fonction,
elle est \textbf{locale}, ce qui veut dire qu'elle n'existe
qu\`a l'int\'erieur de la fonction. Par exemple :

%\index{parentheses!parameters in}
\index{parenth\`eses!param\`etres dans}

%\beforeverb
%\begin{verbatim}
%def cat_twice(part1, part2):
%    cat = part1 + part2
%    print_twice(cat)
%\end{verbatim}
%\afterverb

\beforeverb
\begin{verbatim}
def concatene_deux_fois(partie1, partie2):
    cat = partie1 + partie2
    ecrit_deux_fois(cat)
\end{verbatim}
\afterverb

%This function takes two arguments, concatenates them, and prints
%the result twice.  Here is an example that uses it:

Cette fonction prend deux arguments, les concat\`ene, et imprime
le r\'esultat deux fois. Voici l'exemple d'un programme qui
l'utilise\footnote{NdT : \textit{Bing Tiddle Tidlle Bang} est une autre chanson des Monty Python} :

\index{concatenation}

%\beforeverb
%\begin{verbatim}
%>>> line1 = 'Bing tiddle '
%>>> line2 = 'tiddle bang.'
%>>> cat_twice(line1, line2)
%Bing tiddle tiddle bang.
%Bing tiddle tiddle bang.
%\end{verbatim}
%\afterverb

\beforeverb
\begin{verbatim}
>>> ligne1 = 'Bing tiddle '
>>> ligne2 = 'tiddle bang.'
>>> concatene_deux_fois(ligne1, ligne2)
Bing tiddle tiddle bang.
Bing tiddle tiddle bang.
\end{verbatim}
\afterverb

%When \verb"cat_twice" terminates, the variable {\tt cat}
%is destroyed.  If we try to print it, we get an exception:

Lorsque \verb"concatenation_deux_fois" est termin\'ee, la
variable {\tt cat} est d\'etruite. Si on essaye de l'imprimer,
on obtient une exception :

\index{NameError}
\index{exception!NameError}

\beforeverb
\begin{verbatim}
>>> print cat
NameError: name 'cat' is not defined
\end{verbatim}
\afterverb

%Parameters are also local.
%For example, outside \verb"print_twice", there is no
%such thing as {\tt bruce}.

Les param\`etres sont aussi locaux. Par exemple en dehors 
de \verb"ecrit_deux_fois", il n'existe pas de variable {\tt toto}.

%\index{parameter}
\index{param\`etre}

%\section{Stack diagrams}
%\label{stackdiagram}
%\index{stack diagram}
%\index{function frame}
%\index{frame}
\section{Diagramme de s\'equence (\textit{stack diagram}}
\label{stackdiagram}
\index{diagramme de s\'equence}
\index{cadre de fonction}
\index{cadre}

%To keep track of which variables can be used where, it is sometimes
%useful to draw a {\bf stack diagram}.  Like state diagrams, stack
%diagrams show the value of each variable, but they also show the
%function each variable belongs to.

Pour suivre \`a la trace quelles variables peuvent \^etre 
utilis\'ees \`a quel endroit, il peut \^etre utile de tracer
un \textbf{diagramme de s\'equence}. Comme les diagrammes d'\'etat,
les diagrammes de s\'equence montrent la valeur de chaque variable,
mais en outre indiquent la fonction \`a laquelle appartient chaque
variable.

%\index{stack diagram}
%\index{diagram!stack}
\index{diagramme de s\'equence}
\index{diagramme!s\'equence}

%Each function is represented by a {\bf frame}.  A frame is a box
%with the name of a function
%beside it and the parameters and variables of the function inside it.
%The stack diagram for the
%previous example looks like this:

Chaque fonction est repr\'esent\'ee par un \textbf{cadre}. Un cadre
est une bo\^ite avec le nom de la fonction \`a cot\'e, et les param\`etres
et variables de la fonction \`a l'int\'erieur. Le diagramme
de s\'equence pour l'exemple pr\'ec\'edent est donc :

\beforefig
\centerline{\includegraphics{figs/stack.eps}}
\afterfig

%The frames are arranged in a stack that indicates which function
%called which, and so on.  In this example, \verb"print_twice"
%was called by \verb"cat_twice", and \verb"cat_twice" was called by 
%\verb"__main__", which is a special name for the topmost frame.  When
%you create a variable outside of any function, it belongs to 
%\verb"__main__".

Les cadres sont arrang\'es dans une pile qui indique quelle fonction
appelle quelle autre, etc... Dans cet exemple, \verb"ecrit_deux_fois"
a \'et\'e appell\'e par \verb"concatene_deux_fois" et 
\verb"concatene_deux_fois" a \'et\'e appel\'e par \verb"__main__",
qui est un nom sp\'ecial pour le cadre sup\'erieur. En fait, lorsqu'une
variable est cr\'e\'ee en dehors de toute fonction, elle appartient
\`a \verb"__main__".

%Each parameter refers to the same value as its corresponding
%argument.  So, {\tt part1} has the same value as
%{\tt line1}, {\tt part2} has the same value as {\tt line2},
%and {\tt bruce} has the same value as {\tt cat}.

Chaque param\`etre a pour valeur celle pass\'ee par son argument.
Ainsi {\tt partie1} as la m\^eme valeur que {\tt ligne1},
{\tt partie2} a la m\^eme valeur que {\tt ligne2}, et
{\tt toto} a la m\^eme valeur que {\tt cat}.

%If an error occurs during a function call, Python prints the
%name of the function, and the name of the function that called
%it, and the name of the function that called {\em that}, all the
%way back to \verb"__main__".

Si une erreur se produit durant l'appel \`a une fonction, Python
\'ecrira le nom de la fonction, ainsi que le nom de la fonction
qui l'a appel\'e, puis le nom de la fonction au niveau sup\'erieur,
et ainsi de suite jusqu'au nivea \verb"__main__".

%For example, if you try to access {\tt cat} from within 
%\verb"print_twice", you get a {\tt NameError}:

Par exemple, si vous tentez d'accÃ©der \`a {\tt cat} de l'int\'erieur
de \verb"ecrit_deux_fois", vous obtiendrez une exception {\tt NameError} :

%\beforeverb
%\begin{verbatim}
%Traceback (innermost last):
%  File "test.py", line 13, in __main__
%    cat_twice(line1, line2)
%  File "test.py", line 5, in cat_twice
%    print_twice(cat)
%  File "test.py", line 9, in print_twice
%    print cat
%NameError: name 'cat' is not defined
%\end{verbatim}
%\afterverb
\beforeverb
\begin{verbatim}
Traceback (innermost last):
  File "test.py", line 13, in __main__
    concatene_deux_fois(ligne1, ligne2)
  File "test.py", line 5, in concatene_deux_fois
    ecrit_deux_fois(cat)
  File "test.py", line 9, in ecrit_deux_fois
    print cat
NameError: name 'cat' is not defined
\end{verbatim}
\afterverb

%This list of functions is called a {\bf traceback}.  It tells you what
%program file the error occurred in, and what line, and what functions
%were executing at the time.  It also shows the line of code that
%caused the error.

Cette liste de fonctions est appel\'ee \textbf{pile d'appel}
(\textit{\textbf{traceback}}. Elle indique le nom de fichier du
programme o\`u l'erreur s'est produite, \`a quelle ligne,
et quelles fonctions \'etaient en train d'\^etre \'ex\'ecut\'ees.
Le num\'ero de ligne ayant caus\'e l'erreur est \'egalement donn\'e.

\index{traceback}
\index{pile d'appel}

%The order of the functions in the traceback is the same as the
%order of the frames in the stack diagram.  The function that is
%currently running is at the bottom.

L'ordre des fonctions dans la pile d'appel est la m\^eme que
l'ordre des cadres dans le diagramme de s\'equence. La derni\`ere
fonction \'ex\'ecut\'ee  est indiq\'ee en bas de la pile.

%\section{Fruitful functions and void functions}
\section{Fonctions fructueuses et fonctions \textit{void}}

%\index{fruitful function}
%\index{void function}
%\index{function, fruitful}
%\index{function, void} 
\index{fonction fructueuses}
\index{fonction void}

%Some of the functions we are using, such as the math functions, yield
%results; for lack of a better name, I call them {\bf fruitful
%  functions}.  Other functions, like \verb"print_twice", perform an
%action but don't return a value.  They are called {\bf void
%  functions}.

Certaines des fonctions que nous utilisons, comme les fonctions
math\'ematiques, renvoient un r\'esultat ; \`a d\'efaut d'un meilleur
terme nous les appelerons \textbf{fonctions "fructueuses"}. D'autres
fonctions, telles que \verb"ecrit_deux_fois", ont une action
mais sans renvoyer de valeur. Elles sont appel\'ees
\textbf{fonctions \textit{void}}
\footnote{NdT : \textit{void} : vide, n\'eant}.

%When you call a fruitful function, you almost always
%want to do something with the result; for example, you might
%assign it to a variable or use it as part of an expression:

Lors de l'appel d'une fonction fructueuse, vous souhaitez
normalement utiliser le r\'esultat ; par exemple vous
pouvez l'affecter \`a une variable ou l'utiliser dans
une expression :

%\beforeverb
%\begin{verbatim}
%x = math.cos(radians)
%golden = (math.sqrt(5) + 1) / 2
%\end{verbatim}
%\afterverb
\beforeverb
\begin{verbatim}
x = math.cos(radians)
nombre_d_or = (math.sqrt(5) + 1) / 2
\end{verbatim}
\afterverb

%When you call a function in interactive mode, Python displays
%the result:

Lorsque vous appelez une fonction en mode interactif, Python
affiche le r\'esultat.

\beforeverb
\begin{verbatim}
>>> math.sqrt(5)
2.2360679774997898
\end{verbatim}
\afterverb

%But in a script, if you call a fruitful function all by itself,
%the return value is lost forever!

Mais dans un script, si cous appelez une fonction fructueuse
isol\'ement\footnote{NdT : sans affecter ou utiliser le r\'esultat},
la valeur renvoy\'ee est perdue \`a jamais !

\beforeverb
\begin{verbatim}
math.sqrt(5)
\end{verbatim}
\afterverb

%This script computes the square root of 5, but since it doesn't store
%or display the result, it is not very useful.

Ces lignes de code (\textit{script}) calculent la racine carr\'ee de 5, mais comme
le r\'esultat n'est pas stock\'e ou affich\'e, elles ne sont pas
tr\`es utiles.

%\index{interactive mode}
%\index{script mode}
\index{mode interactif}
\index{mode script}

%Void functions might display something on the screen or have some
%other effect, but they don't have a return value.  If you try to
%assign the result to a variable, you get a special value called
%{\tt None}.

Des fonctions \textit{void} peuvent afficher un r\'esultat \`a
l'\'ecran ou avoir un autre effet, mais elle n'on pas de valeur
de renvoi. N\'eanmoins si cous essayez d'affecter le r\'esultat
\`a la fonction, vous obtiendrez une valeur sp\'eciale
appel\'ee {\tt None}\footnote{NdT : \textit{None} : aucune}.

%\index{None special value}
%\index{special value!None}
\index{None (valeur sp\'eciale)}
\index{valeur sp\'eciale!None}

%\beforeverb
%\begin{verbatim}
%>>> result = print_twice('Bing')
%Ã¹Bing
%Bing
%>>> print result
%None
%\end{verbatim}
%\afterverb
\beforeverb
\begin{verbatim}
>>> resultat = ecrit_deux_fois('Bing')
Bing
Bing
>>> print resultat
None
\end{verbatim}
\afterverb

%The value {\tt None} is not the same as the string \verb"'None'". 
%It is a special value that has its own type:

La valeur {\tt None} n'est pas la m\^eme que la cha\^ine
de caract\`eres \verb"'None'". C'est une valeur sp\'eciale
qui a son propre type :

\beforeverb
\begin{verbatim}
>>> print type(None)
<type 'NoneType'>
\end{verbatim}
\afterverb

%The functions we have written so far are all void.  We will start
%writing fruitful functions in a few chapters.

Toutes les fonctions que nous avons \'ecrites jusqu'ici sont
des fonctions \textit{void}. Nous commencerons \`a \'ecrire
des fonctions fructueuses dans quelques chapitres.

%\section{Why functions?}
%\index{function, reasons for}
\section{Des fonctions, pourquoi faire ?}
\index{fonction, raisons pour}

%It may not be clear why it is worth the trouble to divide
%a program into functions.  There are several reasons:

La raison pour laquelle il peut \^etre int\'eressant de diviser
un programme en fonctions n'est pas forc\'ement claire. Il
y a plusieurs raisons :

\begin{itemize}

%\item Creating a new function gives you an opportunity to name a group
%of statements, which makes your program easier to read and debug.
\item Cr\'eer une nouvelle fonction vous donne la possibilit\'e
de donner un nom \`a un groupe d'instructions, ce qui rend le 
programme plus facile \`a lire et d\'eboguer.

%\item Functions can make a program smaller by eliminating repetitive
%code.  Later, if you make a change, you only have
%to make it in one place.
\item Utiliser des fonctions peut permettre de raccourcir un programme
en \'eliminant du code r\'ep\'etitif. Par la suite, si vous effectuez
un changement, vous n'avez \`a le faire qu\`a un seul endroit.

%\item Dividing a long program into functions allows you to debug the
%parts one at a time and then assemble them into a working whole.
\item Diviser un programme en fonctions permet de d\'eboguer 
diff\'erentes parties une par une, puis de les assembler
en un tout fonctionnel.

%\item Well-designed functions are often useful for many programs.
%Once you write and debug one, you can reuse it.
\item Des fonctions bien con\c{c}ues sont souvent utiles pour
de nombreux programmes. D\`es que vous en avez \'ecrit et
d\'ebogu\'e un, vous pouvez en r\'eutiliser le code.

\end{itemize}

%\section{Debugging}
%\label{editor}
%\index{debugging}
\section{D\'eboguage}
\label{editor}
\index{d\'eboguage}

%If you are using a text editor to write your scripts, you might
%run into problems with spaces and tabs.  The best way to avoid
%these problems is to use spaces exclusively (no tabs).  Most text
%editors that know about Python do this by default, but some
%don't.

Si vous utilisez un \'editeur de texte pour \'ecrire vos programmes,
vous pouvez rencontrer des probl\`emes avec les espaces et les
tabulations. Le meilleur moyen d'\'eviter ces prob\`emes est d'utiliser
exclusivement des espaces. La plupart des \'editeurs de texte
connaissant Python le feront automatiquement, mais certains ne le
feront pas.

%\index{whitespace}
\index{espace}
\index{indentation}

%Tabs and spaces are usually invisible, which makes them
%hard to debug, so try to find an editor that manages indentation
%for you.

Les tabulations et espaces sont normalement invisibles, ce
qui les rend difficile \`a d\'eboguer ; essayez donc de trouver
un \'editeur qui s'occupe de l'indentation \`a votre place.

%Also, don't forget to save your program before you run it.  Some
%development environments do this automatically, but some don't.
%In that case the program you are looking at in the text editor
%is not the same as the program you are running.

Aussi, n'oubliez pas d'enregistrer votre programme avant de 
l'\'ex\'ecuter. Certains environnements de d\'eveloppement le
font automatiquement, mais d'autres pas. Dans ce cas le programme
que vous regardez dans l\'editeur de texte n'est pas le m\^eme
que celui que vous \'ex\'ecutez.

%Debugging can take a long time if you keep running the same,
%incorrect, program over and over!

Le d\'eboguage peut prendre beaucoup de temps si vous continuez
\`a \'ex\'ecuter le m\^eme programme erron\'e \`a r\'ep\'etition !

%Make sure that the code you are looking at is the code you are running.
%If you're not sure, put something like \verb"print 'hello'" at the
%beginning of the program and run it again.  If you don't see
%\verb"hello", you're not running the right program!

Assurez-vous que le code que vous regardez est bien celui que vous
\'ex\'ecutez. Si vous n'en \^etes pas certain, ajoutez un
code quelconque comme \verb"print 'salut'" au d\'ebut du
programme et r\'e-\'ex\'ecutez-le. Si vous ne voyez pas \verb"salut",
vous n\^etes pas en train d'\'ex\'ecuter le bon programme !

%\section{Glossary}
\section{Glossaire}

\begin{description}

\item[function:] A named sequence of statements that performs some
useful operation.  Functions may or may not take arguments and may or
may not produce a result.
\index{function}

\item[function definition:]  A statement that creates a new function,
specifying its name, parameters, and the statements it executes.
\index{function definition}

\item[function object:]  A value created by a function definition.
The name of the function is a variable that refers to a function
object.
\index{function definition}

\item[header:] The first line of a function definition.
\index{header}

\item[body:] The sequence of statements inside a function definition.
\index{body}

\item[parameter:] A name used inside a function to refer to the value
passed as an argument.
\index{parameter}

\item[function call:] A statement that executes a function. It
consists of the function name followed by an argument list.
\index{function call}

\item[argument:]  A value provided to a function when the function is called.
This value is assigned to the corresponding parameter in the function.
\index{argument}

\item[local variable:]  A variable defined inside a function.  A local
variable can only be used inside its function.
\index{local variable}

\item[return value:]  The result of a function.  If a function call
is used as an expression, the return value is the value of
the expression.
\index{return value}

\item[fruitful function:] A function that returns a value.
\index{fruitful function}

\item[void function:] A function that doesn't return a value.
\index{void function}

\item[module:] A file that contains a
collection of related functions and other definitions.
\index{module}

\item[import statement:] A statement that reads a module file and creates
a module object.
\index{import statement}
\index{statement!import}

\item[module object:] A value created by an {\tt import} statement
that provides access to the values defined in a module.
\index{module}

\item[dot notation:]  The syntax for calling a function in another
module by specifying the module name followed by a dot (period) and
the function name.
\index{dot notation}

\item[composition:] Using an expression as part of a larger expression,
or a statement as part of a larger statement.
\index{composition}

\item[flow of execution:]  The order in which statements are executed during
a program run.
\index{flow of execution}

\item[stack diagram:]  A graphical representation of a stack of functions,
their variables, and the values they refer to.
\index{stack diagram}

\item[frame:]  A box in a stack diagram that represents a function call.
It contains the local variables and parameters of the function.
\index{function frame}
\index{frame}

\item[traceback:]  A list of the functions that are executing,
printed when an exception occurs.
\index{traceback}


\end{description}


\section{Exercises}

\begin{ex}

\index{len function}
\index{function!len}

Python provides a built-in function called {\tt len} that
returns the length of a string, so the value of \verb"len('allen')" is 5.

Write a function named \verb"right_justify" that takes a string
named {\tt s} as a parameter and prints the string with enough
leading spaces so that the last letter of the string is in column 70
of the display.

\beforeverb
\begin{verbatim}
>>> right_justify('allen')
                                                                 allen
\end{verbatim}
\afterverb

\end{ex}


\begin{ex}
\index{function object}
\index{object!function}

A function object is a value you can assign to a variable
or pass as an argument.  For example, \verb"do_twice" is a function
that takes a function object as an argument and calls it twice:

\beforeverb
\begin{verbatim}
def do_twice(f):
    f()
    f()
\end{verbatim}
\afterverb

Here's an example that uses \verb"do_twice" to call a function
named \verb"print_spam" twice.

\beforeverb
\begin{verbatim}
def print_spam():
    print 'spam'

do_twice(print_spam)
\end{verbatim}
\afterverb

\begin{enumerate}

\item Type this example into a script and test it.

\item Modify \verb"do_twice" so that it takes two arguments, a
function object and a value, and calls the function twice,
passing the value as an argument.

\item Use the modified version of \verb"do_twice" to call
\verb"print_twice" twice, passing \verb"'spam'" as an argument.

\item Define a new function called 
\verb"do_four" that takes a function object and a value
and calls the function four times.  There should be only
two statements in the body of this function, not four.

\end{enumerate}

You can see my solution at \url{thinkpython.com/code/do_four.py}.

\end{ex}



\begin{ex}
This exercise\footnote{Based on an exercise in Oualline, {\em
    Practical C Programming, Third Edition}, O'Reilly (1997)} can be
done using only the statements and other features we have learned so
far.  

\index{grid}

\begin{enumerate}

\item Write a function that draws a grid like the
  following:

\beforeverb
\begin{verbatim}
+ - - - - + - - - - +
|         |         |
|         |         |
|         |         |
|         |         |
+ - - - - + - - - - +
|         |         |
|         |         |
|         |         |
|         |         |
+ - - - - + - - - - +
\end{verbatim}
\afterverb
%
Hint: to print more than one value on a line, you can print
a comma-separated sequence:

\beforeverb
\begin{verbatim}
print '+', '-'
\end{verbatim}
\afterverb
%
If the sequence ends with a comma, Python leaves the line unfinished,
so the value printed next appears on the same line.

\beforeverb
\begin{verbatim}
print '+', 
print '-'
\end{verbatim}
\afterverb
%
The output of these statements is \verb"'+ -'".

A {\tt print} statement all by itself ends the current line and
goes to the next line.

\item Use the previous function to draw a similar grid
with four rows and four columns.

\end{enumerate}

You can see my solution at \url{thinkpython.com/code/grid.py}.

\end{ex}
